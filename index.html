<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Wouldn't you like to know, coffee boy</title>
    <script src="https://cdn.jsdelivr.net/npm/echarts@5.4.3/dist/echarts.min.js"></script>
    <script src="/socket.io/socket.io.js"></script>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        :root {
            --bg-primary: #ffffff;
            --bg-secondary: #f8f9fa;
            --bg-card: #ffffff;
            --text-primary: #2c3e50;
            --text-secondary: #7f8c8d;
            --border: #e0e0e0;
            --accent: #e74c3c;
            --accent-secondary: #3498db;
            --success: #27ae60;
            --warning: #f39c12;
            --shadow: rgba(0, 0, 0, 0.1);
        }

        body.dark-mode {
            --bg-primary: #1a1a1a;
            --bg-secondary: #2d2d2d;
            --bg-card: #252525;
            --text-primary: #e0e0e0;
            --text-secondary: #a0a0a0;
            --border: #404040;
            --shadow: rgba(0, 0, 0, 0.3);
        }

        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, Oxygen, Ubuntu, sans-serif;
            background: var(--bg-primary);
            color: var(--text-primary);
            line-height: 1.6;
            transition: background 0.3s, color 0.3s;
        }

        .container {
            max-width: 1400px;
            margin: 0 auto;
            padding: 20px;
        }

        header {
            display: flex;
            justify-content: space-between;
            align-items: center;
            margin-bottom: 30px;
            padding-bottom: 20px;
            border-bottom: 2px solid var(--border);
        }

        h1 {
            font-size: 2rem;
            font-weight: 600;
            display: flex;
            align-items: center;
            gap: 10px;
        }

        .header-controls {
            display: flex;
            gap: 15px;
            align-items: center;
        }

        .status-indicator {
            display: flex;
            align-items: center;
            gap: 8px;
            padding: 8px 16px;
            background: var(--bg-card);
            border-radius: 20px;
            border: 1px solid var(--border);
            font-size: 0.9rem;
        }

        .status-dot {
            width: 10px;
            height: 10px;
            border-radius: 50%;
            background: var(--success);
            animation: pulse 2s infinite;
        }

        .status-dot.disconnected {
            background: var(--warning);
            animation: none;
        }

        @keyframes pulse {
            0%, 100% { opacity: 1; }
            50% { opacity: 0.5; }
        }

        .theme-toggle {
            background: var(--bg-card);
            border: 1px solid var(--border);
            color: var(--text-primary);
            padding: 10px 20px;
            border-radius: 8px;
            cursor: pointer;
            font-size: 1.2rem;
            transition: all 0.3s;
        }

        .theme-toggle:hover {
            transform: translateY(-2px);
            box-shadow: 0 4px 12px var(--shadow);
        }

        .stats-grid {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));
            gap: 20px;
            margin-bottom: 30px;
        }

        .stat-card {
            background: var(--bg-card);
            padding: 24px;
            border-radius: 12px;
            border: 1px solid var(--border);
            box-shadow: 0 2px 8px var(--shadow);
            transition: transform 0.3s, box-shadow 0.3s;
        }

        .stat-card:hover {
            transform: translateY(-4px);
            box-shadow: 0 4px 16px var(--shadow);
        }

        .stat-label {
            font-size: 0.9rem;
            color: var(--text-secondary);
            margin-bottom: 8px;
            text-transform: uppercase;
            letter-spacing: 0.5px;
        }

        .stat-value {
            font-size: 2.5rem;
            font-weight: 700;
            color: var(--accent);
        }

        .stat-value.output {
            color: var(--accent-secondary);
        }

        .stat-value.target {
            color: var(--success);
        }

        .controls-panel {
            background: var(--bg-card);
            padding: 24px;
            border-radius: 12px;
            border: 1px solid var(--border);
            box-shadow: 0 2px 8px var(--shadow);
            margin-bottom: 30px;
        }

        .control-group {
            margin-bottom: 24px;
        }

        .control-group:last-child {
            margin-bottom: 0;
        }

        .control-label {
            font-size: 1rem;
            font-weight: 600;
            margin-bottom: 12px;
            display: block;
        }

        .mode-buttons {
            display: flex;
            gap: 12px;
        }

        .mode-btn {
            flex: 1;
            padding: 16px;
            border: 2px solid var(--border);
            background: var(--bg-secondary);
            color: var(--text-primary);
            border-radius: 8px;
            font-size: 1.1rem;
            font-weight: 600;
            cursor: pointer;
            transition: all 0.3s;
            display: flex;
            align-items: center;
            justify-content: center;
            gap: 8px;
        }

        .mode-btn:hover {
            border-color: var(--accent);
            transform: translateY(-2px);
        }

        .mode-btn.active {
            background: var(--accent);
            color: white;
            border-color: var(--accent);
        }

        .temp-slider-container {
            display: flex;
            flex-direction: column;
            gap: 12px;
        }

        .temp-input-row {
            display: flex;
            gap: 12px;
            align-items: center;
        }

        .temp-slider {
            flex: 1;
            height: 8px;
            border-radius: 4px;
            background: var(--bg-secondary);
            outline: none;
            appearance: none;
            -webkit-appearance: none;
        }

        .temp-slider::-webkit-slider-thumb {
            -webkit-appearance: none;
            appearance: none;
            width: 24px;
            height: 24px;
            border-radius: 50%;
            background: var(--accent);
            cursor: pointer;
            transition: all 0.3s;
        }

        .temp-slider::-webkit-slider-thumb:hover {
            transform: scale(1.2);
        }

        .temp-slider::-moz-range-thumb {
            width: 24px;
            height: 24px;
            border-radius: 50%;
            background: var(--accent);
            cursor: pointer;
            border: none;
            transition: all 0.3s;
        }

        .temp-input {
            width: 80px;
            padding: 12px;
            border: 2px solid var(--border);
            background: var(--bg-secondary);
            color: var(--text-primary);
            border-radius: 8px;
            font-size: 1.1rem;
            font-weight: 600;
            text-align: center;
        }

        .apply-btn {
            padding: 12px 32px;
            background: var(--success);
            color: white;
            border: none;
            border-radius: 8px;
            font-size: 1rem;
            font-weight: 600;
            cursor: pointer;
            transition: all 0.3s;
        }

        .apply-btn:hover {
            transform: translateY(-2px);
            box-shadow: 0 4px 12px var(--shadow);
        }

        .apply-btn:active {
            transform: translateY(0);
        }

        .chart-container {
            background: var(--bg-card);
            padding: 24px;
            border-radius: 12px;
            border: 1px solid var(--border);
            box-shadow: 0 2px 8px var(--shadow);
            margin-bottom: 20px;
        }

        #chart {
            width: 100%;
            height: 500px;
        }

        .last-update {
            text-align: center;
            color: var(--text-secondary);
            font-size: 0.9rem;
            margin-top: 10px;
        }

            .api-key-panel {
                background: var(--bg-card);
                padding: 20px;
                border-radius: 12px;
                border: 1px solid var(--border);
                box-shadow: 0 2px 8px var(--shadow);
                margin-top: 20px;
            }

            .api-key-label {
                display: block;
                font-size: 0.9rem;
                font-weight: 600;
                color: var(--text-primary);
                margin-bottom: 10px;
            }

            .api-key-input-group {
                display: flex;
                gap: 10px;
                align-items: center;
            }

            .api-key-input {
                flex: 1;
                padding: 10px 12px;
                border: 2px solid var(--border);
                background: var(--bg-secondary);
                color: var(--text-primary);
                border-radius: 8px;
                font-size: 1rem;
                font-family: monospace;
            }

            .api-key-input:focus {
                outline: none;
                border-color: var(--accent);
            }

            .api-key-checkbox-label {
                display: flex;
                align-items: center;
                gap: 5px;
                font-size: 0.9rem;
                color: var(--text-secondary);
                cursor: pointer;
                user-select: none;
            }

            .api-key-checkbox {
                cursor: pointer;
            }

            .api-key-save-btn {
                padding: 10px 20px;
                background: var(--accent);
                color: white;
                border: none;
                border-radius: 8px;
                font-size: 0.9rem;
                font-weight: 600;
                cursor: pointer;
                transition: all 0.3s;
            }

            .api-key-save-btn:hover {
                transform: translateY(-2px);
                box-shadow: 0 4px 12px var(--shadow);
            }

            .api-key-status {
                margin-top: 10px;
                font-size: 0.85rem;
                color: var(--text-secondary);
            }

            .api-key-status.saved {
                color: var(--success);
            }

            .api-key-status.error {
                color: var(--danger);
            }

            @media (max-width: 768px) {
                .container {
                    padding: 10px;
                }

                h1 {
                    font-size: 1.5rem;
                }

                .stats-grid {
                    grid-template-columns: 1fr;
                }

                .mode-buttons {
                    flex-direction: column;
                }

                #chart {
                    height: 400px;
                }

                .header-controls {
                    flex-direction: column;
                    gap: 10px;
                }

                .api-key-input-group {
                    flex-direction: column;
                    align-items: stretch;
                }

                .api-key-save-btn {
                    width: 100%;
                }
            }

        .notification {
            position: fixed;
            top: 20px;
            right: 20px;
            padding: 16px 24px;
            background: var(--success);
            color: white;
            border-radius: 8px;
            box-shadow: 0 4px 16px var(--shadow);
            z-index: 1000;
            animation: slideIn 0.3s;
        }

        @keyframes slideIn {
            from {
                transform: translateX(400px);
                opacity: 0;
            }
            to {
                transform: translateX(0);
                opacity: 1;
            }
        }
    </style>
</head>
<body>
    <div class="container">
        <header>
            <h1>
                <span>â˜•</span>
                Silvia PID Controller
            </h1>
            <div class="header-controls">
                <div class="status-indicator">
                    <div class="status-dot" id="statusDot"></div>
                    <span id="statusText">Connecting...</span>
                </div>
                <button class="theme-toggle" id="themeToggle" title="Toggle dark mode">
                    ðŸŒ™
                </button>
            </div>
        </header>

            <div class="stats-grid">
                <div class="stat-card">
                    <div class="stat-label">Current Temperature</div>
                    <div class="stat-value" id="currentTemp">--</div>
                </div>
                <div class="stat-card">
                    <div class="stat-label">Target Temperature</div>
                    <div class="stat-value target" id="targetTemp">--</div>
                </div>
                <div class="stat-card">
                    <div class="stat-label">Heater Output</div>
                    <div class="stat-value output" id="outputPercent">--</div>
                </div>
                <div class="stat-card">
                    <div class="stat-label">Machine State</div>
                    <div class="stat-value" id="machineState">--</div>
                    <div class="stat-label" style="font-size: 0.75rem; margin-top: 5px; opacity: 0.7;" id="machineStateDesc"></div>
                </div>
                <div class="stat-card">
                    <div class="stat-label">PID Mode</div>
                    <div class="stat-value" id="pidMode">--</div>
                    <div class="stat-label" style="font-size: 0.75rem; margin-top: 5px; opacity: 0.7;" id="pidModeDesc"></div>
                </div>
            </div>

        <div class="controls-panel">
            <div class="control-group">
                <label class="control-label">Mode</label>
                <div class="mode-buttons">
                    <button class="mode-btn active" id="espressoBtn" data-mode="espresso">
                        <span>â˜•</span> Espresso
                    </button>
                    <button class="mode-btn" id="steamBtn" data-mode="steam">
                        <span>ðŸ«–</span> Steam
                    </button>
                </div>
            </div>

            <div class="control-group">
                <label class="control-label">Target Temperature: <span id="tempDisplay">100</span>Â°C</label>
                <div class="temp-slider-container">
                    <div class="temp-input-row">
                        <input type="range" class="temp-slider" id="tempSlider" min="80" max="150" value="100" step="1">
                        <input type="number" class="temp-input" id="tempInput" min="80" max="150" value="100">
                    </div>
                    <button class="apply-btn" id="applyBtn">Apply Temperature</button>
                </div>
            </div>
        </div>

            <div class="chart-container">
                <div id="chart"></div>
                <div class="last-update">Last update: <span id="lastUpdate">--</span></div>
            </div>

            <div class="api-key-panel">
                <label class="api-key-label">API Key:</label>
                <div class="api-key-input-group">
                    <input type="password" id="apiKeyInput" class="api-key-input" placeholder="Enter API key for write operations">
                    <label class="api-key-checkbox-label">
                        <input type="checkbox" id="apiKeyShow" class="api-key-checkbox">
                        Show
                    </label>
                    <button id="apiKeySave" class="api-key-save-btn">Save</button>
                </div>
                <div class="api-key-status" id="apiKeyStatus"></div>
            </div>
        </div>

    <script>
        class SilviaDashboard {
            constructor() {
                this.chartData = {
                    temperature: [],
                    output: []
                };
                this.currentTemp = 0;
                this.currentOutput = 0;
                this.targetTemp = 100;
                this.mode = 'espresso';
                this.espressoTemp = 100;
                this.steamTemp = 140;
                
                this.initChart();
                this.initWebSocket();
                this.initControls();
                this.initTheme();
                this.initApiKey(); // Initialize API key management
                this.loadCurrentMode(); // Load current mode from server on startup
                
                // Initialize PID mode display
                this.updatePIDMode(undefined);
            }

            initChart() {
                const chartDom = document.getElementById('chart');
                this.chart = echarts.init(chartDom);

                const isDark = document.body.classList.contains('dark-mode');
                
                const option = {
                    backgroundColor: 'transparent',
                    title: {
                        text: 'Temperature & Output History',
                        left: 'center',
                        textStyle: {
                            color: getComputedStyle(document.documentElement)
                                .getPropertyValue('--text-primary')
                        }
                    },
                    tooltip: {
                        trigger: 'axis',
                        axisPointer: {
                            type: 'cross'
                        },
                        formatter: function (params) {
                            const time = new Date(params[0].value[0]).toLocaleTimeString();
                            let result = `<strong>${time}</strong><br/>`;
                            params.forEach(param => {
                                result += `${param.marker} ${param.seriesName}: <strong>${param.value[1].toFixed(1)}${param.seriesName.includes('Temperature') ? 'Â°C' : '%'}</strong><br/>`;
                            });
                            return result;
                        }
                    },
                    legend: {
                        data: ['Temperature', 'Heater Output'],
                        top: 35,
                        textStyle: {
                            color: getComputedStyle(document.documentElement)
                                .getPropertyValue('--text-primary')
                        }
                    },
                    grid: {
                        left: '3%',
                        right: '4%',
                        bottom: '3%',
                        containLabel: true
                    },
                    xAxis: {
                        type: 'time',
                        boundaryGap: false,
                        axisLine: {
                            lineStyle: {
                                color: getComputedStyle(document.documentElement)
                                    .getPropertyValue('--border')
                            }
                        },
                        axisLabel: {
                            color: getComputedStyle(document.documentElement)
                                .getPropertyValue('--text-secondary')
                        }
                    },
                    yAxis: [
                        {
                            type: 'value',
                            name: 'Temperature (Â°C)',
                            min: 0,
                            max: 160,
            position: 'left',
                            axisLine: {
                                lineStyle: {
                                    color: '#e74c3c'
                                }
                            },
                            axisLabel: {
                                formatter: '{value}Â°C',
                                color: getComputedStyle(document.documentElement)
                                    .getPropertyValue('--text-secondary')
                            },
                            splitLine: {
                                lineStyle: {
                                    color: getComputedStyle(document.documentElement)
                                        .getPropertyValue('--border')
                                }
                            }
                        },
                        {
                            type: 'value',
                            name: 'Output (%)',
              min: 0,
                            max: 100,
                            position: 'right',
                            axisLine: {
                                lineStyle: {
                                    color: '#3498db'
                                }
                            },
                            axisLabel: {
                                formatter: '{value}%',
                                color: getComputedStyle(document.documentElement)
                                    .getPropertyValue('--text-secondary')
                            },
                            splitLine: {
                                show: false
                            }
                        }
                    ],
                    series: [
                        {
                            name: 'Temperature',
                            type: 'line',
                            smooth: true,
                            yAxisIndex: 0,
                            data: [],
                            itemStyle: {
                                color: '#e74c3c'
                            },
                            lineStyle: {
                                width: 3
                            },
                            areaStyle: {
                                color: new echarts.graphic.LinearGradient(0, 0, 0, 1, [
                                    { offset: 0, color: 'rgba(231, 76, 60, 0.3)' },
                                    { offset: 1, color: 'rgba(231, 76, 60, 0.0)' }
                                ])
                            }
                        },
                        {
                            name: 'Heater Output',
                            type: 'line',
                            smooth: true,
                            yAxisIndex: 1,
                            data: [],
                            itemStyle: {
                                color: '#3498db'
                            },
                            lineStyle: {
                                width: 2,
                                type: 'dashed'
                            }
                        }
                    ]
                };

                this.chart.setOption(option);
                
                // Responsive resize
                window.addEventListener('resize', () => {
                    this.chart.resize();
                });
            }

            initWebSocket() {
                // Socket.IO v4.x - use io() instead of io.connect()
                // Use secure connection if page is loaded via HTTPS
                const isSecure = window.location.protocol === 'https:';
                this.socket = io({
                    secure: isSecure,
                    reconnection: true,
                    reconnectionDelay: 1000,
                    reconnectionDelayMax: 5000,
                    reconnectionAttempts: Infinity
                });
                
                this.socket.on('connect', () => {
                    console.log('Connected to server');
                    this.updateStatus(true);
                });

                this.socket.on('disconnect', (reason) => {
                    console.log('Disconnected from server:', reason);
                    this.updateStatus(false);
                });

                // Receive full history on initial connection
                this.socket.on('temp_history', (data) => {
                    console.log(`Received ${data.length} historical records`);
                    this.chartData.temperature = [];
                    this.chartData.output = [];
                    
                    data.forEach(record => {
                        this.chartData.temperature.push([record.timestamp, record.temperature]);
                        this.chartData.output.push([record.timestamp, record.output]);
                    });
                    
                    this.updateChart();
                    
                    // Update current values with latest data
                    if (data.length > 0) {
                        const latest = data[data.length - 1];
                        // pid_mode might not exist in old records, use undefined if missing
                        this.updateCurrentValues(latest.temperature, latest.output, latest.pid_mode || undefined);
                    }
                });

                    // Receive incremental updates
                    this.socket.on('temp_update', (newData) => {
                        let latestRecord = null;
                        newData.forEach(record => {
                            this.chartData.temperature.push([record.timestamp, record.temperature]);
                            this.chartData.output.push([record.timestamp, record.output]);
                            latestRecord = record; // Keep track of latest record
                        });
                        
                        // Update current values with latest record (includes pid_mode)
                        if (latestRecord) {
                            // pid_mode might not exist in old records, use undefined if missing
                            this.updateCurrentValues(latestRecord.temperature, latestRecord.output, latestRecord.pid_mode || undefined);
                        }
                    
                    // Keep last 600 points (10 minutes at 1 sec intervals)
                    if (this.chartData.temperature.length > 600) {
                        this.chartData.temperature = this.chartData.temperature.slice(-600);
                        this.chartData.output = this.chartData.output.slice(-600);
                    }
                    
                    this.updateChart();
                    this.updateLastUpdateTime();
                });

                this.socket.on('connect_error', (error) => {
                    console.error('Connection error:', error);
                    this.updateStatus(false);
                });

                    // Listen for mode changes (e.g., steam timeout)
                    this.socket.on('mode_change', (data) => {
                        console.log('Mode changed:', data);
                        if (data.mode === 'espresso' && data.reason === 'steam_timeout') {
                            this.setMode('espresso', 100);
                            this.showNotification('Steam timeout - switched to espresso mode');
                        }
                    });

                    // Listen for machine state updates
                    this.socket.on('machine_state', (data) => {
                        console.log('Machine state update:', data);
                        if (data.machine_state) {
                            this.updateMachineState(data.machine_state, data.machine_state_updated);
                        }
                    });
                }

            async loadCurrentMode() {
                try {
                    const response = await fetch('/api/mode', this.getFetchOptions());
                    const data = await response.json();
                    
                    if (data.mode && data.target_temperature) {
                        // Store saved temperatures for each mode
                        this.espressoTemp = data.espresso_temperature || 100;
                        this.steamTemp = data.steam_temperature || 140;
                        
                        // Update mode button labels with saved temperatures
                        document.getElementById('espressoBtn').innerHTML = `<span>â˜•</span> Espresso (${this.espressoTemp}Â°C)`;
                        document.getElementById('steamBtn').innerHTML = `<span>ðŸ«–</span> Steam (${this.steamTemp}Â°C)`;
                        
                        // Restore the actual mode and temperature from server
                        this.mode = data.mode;
                        this.targetTemp = data.target_temperature;
                        
                        // Update UI to match server state
                        this.setMode(data.mode, data.target_temperature);
                        
                        // If in steam mode and timer is active, start the countdown
                        if (data.mode === 'steam' && data.steam_time_remaining) {
                            this.startSteamTimer(data.steam_time_remaining);
                        }
                        
                        console.log(`Restored mode: ${data.mode} at ${data.target_temperature}Â°C`);
                    }
                } catch (err) {
                    console.error('Error loading current mode:', err);
                    // Continue with default espresso mode if fetch fails
                }
            }

            updateMachineState(state, updatedTime) {
                const stateElement = document.getElementById('machineState');
                const descElement = document.getElementById('machineStateDesc');
                
                if (!stateElement || !descElement) return;
                
                // Capitalize first letter
                const displayState = state ? state.charAt(0).toUpperCase() + state.slice(1) : 'Unknown';
                stateElement.textContent = displayState;
                
                // Set color based on state
                const stateColors = {
                    'off': 'var(--text-secondary)',
                    'heating': 'var(--warning)',
                    'ready': 'var(--success)',
                    'unknown': 'var(--text-secondary)'
                };
                stateElement.style.color = stateColors[state] || stateColors['unknown'];
                
                // Update description
                const descriptions = {
                    'off': 'Machine is off (temperature not rising) - data not being recorded',
                    'heating': 'Machine is heating up (temperature rising)',
                    'ready': 'Machine is ready (at or near target temperature)',
                    'unknown': 'Machine state unknown'
                };
                descElement.textContent = descriptions[state] || descriptions['unknown'];
                
                // Show update time if available
                if (updatedTime) {
                    const updateDate = new Date(updatedTime);
                    const timeStr = updateDate.toLocaleTimeString();
                    descElement.textContent += ` (updated: ${timeStr})`;
                }
            }


            updateChart() {
                this.chart.setOption({
                    series: [
                        { data: this.chartData.temperature },
                        { data: this.chartData.output }
                    ]
                });
            }

                updateCurrentValues(temp, output, pidMode) {
                    this.currentTemp = temp;
                    this.currentOutput = output;
                    
                    document.getElementById('currentTemp').textContent = temp.toFixed(1) + 'Â°C';
                    document.getElementById('outputPercent').textContent = output.toFixed(0) + '%';
                    
                    // Update PID mode if provided
                    if (pidMode !== undefined) {
                        this.updatePIDMode(pidMode);
                    }
                }

                updatePIDMode(mode) {
                    const modeElement = document.getElementById('pidMode');
                    const descElement = document.getElementById('pidModeDesc');
                    
                    if (!modeElement || !descElement) return;
                    
                    // Handle missing or undefined mode
                    if (!mode || mode === 'undefined' || mode === 'null') {
                        modeElement.textContent = '--';
                        modeElement.style.color = 'var(--text-secondary)';
                        descElement.textContent = 'Waiting for data...';
                        return;
                    }
                    
                    // Capitalize first letter
                    const displayMode = mode.charAt(0).toUpperCase() + mode.slice(1);
                    modeElement.textContent = displayMode;
                    
                    // Set color based on mode
                    const modeColors = {
                        'normal': 'var(--accent)',
                        'recovery': 'var(--warning)',
                        'unknown': 'var(--text-secondary)'
                    };
                    modeElement.style.color = modeColors[mode] || modeColors['unknown'];
                    
                    // Update description
                    const descriptions = {
                        'normal': 'Normal PID operation (maintaining temperature)',
                        'recovery': 'Recovery mode (faster heating after cold water refill)',
                        'unknown': 'PID mode unknown'
                    };
                    descElement.textContent = descriptions[mode] || descriptions['unknown'];
                }

            updateStatus(connected) {
                const dot = document.getElementById('statusDot');
                const text = document.getElementById('statusText');
                
                if (connected) {
                    dot.classList.remove('disconnected');
                    text.textContent = 'Connected';
                } else {
                    dot.classList.add('disconnected');
                    text.textContent = 'Disconnected';
                }
            }

            updateLastUpdateTime() {
                const now = new Date().toLocaleTimeString();
                document.getElementById('lastUpdate').textContent = now;
            }

            initControls() {
                const espressoBtn = document.getElementById('espressoBtn');
                const steamBtn = document.getElementById('steamBtn');
                const tempSlider = document.getElementById('tempSlider');
                const tempInput = document.getElementById('tempInput');
                const tempDisplay = document.getElementById('tempDisplay');
                const applyBtn = document.getElementById('applyBtn');

                // Mode buttons
                espressoBtn.addEventListener('click', () => {
                    this.setModeAPI('espresso');
                });

                steamBtn.addEventListener('click', () => {
                    this.setModeAPI('steam');
                });

                // Temperature slider and input sync
                tempSlider.addEventListener('input', (e) => {
                    const value = e.target.value;
                    tempInput.value = value;
                    tempDisplay.textContent = value;
                });

                tempInput.addEventListener('input', (e) => {
                    const value = Math.min(150, Math.max(80, e.target.value));
                    tempSlider.value = value;
                    tempDisplay.textContent = value;
                });

                // Apply button
                applyBtn.addEventListener('click', () => {
                    const newTemp = parseInt(tempInput.value);
                    this.applyTemperature(newTemp);
                });
            }

            setMode(mode, temp) {
                this.mode = mode;
                
                // Update button states
                document.getElementById('espressoBtn').classList.toggle('active', mode === 'espresso');
                document.getElementById('steamBtn').classList.toggle('active', mode === 'steam');
                
                // Update temperature controls
                document.getElementById('tempSlider').value = temp;
                document.getElementById('tempInput').value = temp;
                document.getElementById('tempDisplay').textContent = temp;
                document.getElementById('targetTemp').textContent = temp + 'Â°C';
                this.targetTemp = temp;
            }

            async setModeAPI(mode) {
                try {
                    const response = await fetch(`/api/mode/${mode}`, this.getFetchOptions());
                    
                    // Handle 403 (authentication required)
                    if (response.status === 403) {
                        const errorData = await response.json();
                        this.showNotification(errorData.message || 'API key required', 'error');
                        document.getElementById('apiKeyStatus').textContent = 'API key required or invalid';
                        document.getElementById('apiKeyStatus').className = 'api-key-status error';
                        return;
                    }
                    
                    const data = await response.json();
                    if (data.success) {
                        const temp = data.temperature;
                        this.setMode(mode, temp);
                        
                        // Update saved temperature for this mode
                        if (mode === 'espresso') {
                            this.espressoTemp = temp;
                            document.getElementById('espressoBtn').innerHTML = `<span>â˜•</span> Espresso (${temp}Â°C)`;
                        } else if (mode === 'steam') {
                            this.steamTemp = temp;
                            document.getElementById('steamBtn').innerHTML = `<span>ðŸ«–</span> Steam (${temp}Â°C)`;
                        }
                        
                        if (mode === 'steam' && data.timeout_seconds) {
                            this.showNotification(`Steam mode activated (${data.timeout_seconds}s timeout)`);
                            this.startSteamTimer(data.timeout_seconds);
                        } else {
                            this.showNotification(`Switched to ${mode} mode`);
                            this.clearSteamTimer();
                        }
                    } else {
                        this.showNotification('Failed to set mode', 'error');
                    }
                } catch (err) {
                    console.error('Error setting mode:', err);
                    this.showNotification('Error setting mode', 'error');
                }
            }

            async applyTemperature(temp) {
                try {
                    const response = await fetch(`/api/temp/set/${temp}`, this.getFetchOptions());
                    
                    // Handle 403 (authentication required)
                    if (response.status === 403) {
                        const errorData = await response.json();
                        this.showNotification(errorData.message || 'API key required', 'error');
                        document.getElementById('apiKeyStatus').textContent = 'API key required or invalid';
                        document.getElementById('apiKeyStatus').className = 'api-key-status error';
                        return;
                    }
                    
                    const data = await response.json();
                    if (response.ok && data.success) {
                        this.targetTemp = temp;
                        document.getElementById('targetTemp').textContent = temp + 'Â°C';
                        
                        // Update saved temperature for current mode and button label
                        if (this.mode === 'espresso') {
                            this.espressoTemp = temp;
                            document.getElementById('espressoBtn').innerHTML = `<span>â˜•</span> Espresso (${temp}Â°C)`;
                        } else if (this.mode === 'steam') {
                            this.steamTemp = temp;
                            document.getElementById('steamBtn').innerHTML = `<span>ðŸ«–</span> Steam (${temp}Â°C)`;
                        }
                        
                        this.showNotification(`Target temperature set to ${temp}Â°C (saved for ${this.mode} mode)`);
                    } else {
                        const errorMsg = data.message || data.error || 'Failed to set temperature';
                        console.error('Failed to set temperature:', errorMsg);
                        this.showNotification(errorMsg, 'error');
                    }
                } catch (err) {
                    console.error('Error setting temperature:', err);
                    this.showNotification('Error setting temperature', 'error');
                }
            }

            startSteamTimer(seconds) {
                this.clearSteamTimer();
                
                let remaining = seconds;
                const timerElement = document.getElementById('currentMode');
                
                this.steamTimerInterval = setInterval(() => {
                    remaining--;
                    if (remaining > 0) {
                        const minutes = Math.floor(remaining / 60);
                        const secs = remaining % 60;
                        timerElement.textContent = `Steam (${minutes}:${secs.toString().padStart(2, '0')})`;
                    } else {
                        this.clearSteamTimer();
                        timerElement.textContent = 'Espresso';
                    }
                }, 1000);
            }

            clearSteamTimer() {
                if (this.steamTimerInterval) {
                    clearInterval(this.steamTimerInterval);
                    this.steamTimerInterval = null;
                }
            }

            showNotification(message, type = 'success') {
                const notification = document.createElement('div');
                notification.className = 'notification';
                notification.style.background = type === 'success' ? 'var(--success)' : 'var(--warning)';
                notification.textContent = message;
                
                document.body.appendChild(notification);
                
                setTimeout(() => {
                    notification.remove();
                }, 3000);
            }

            initTheme() {
                const themeToggle = document.getElementById('themeToggle');
                const savedTheme = localStorage.getItem('theme');
                
                if (savedTheme === 'dark') {
                    document.body.classList.add('dark-mode');
                    themeToggle.textContent = 'â˜€ï¸';
                }
                
                themeToggle.addEventListener('click', () => {
                    document.body.classList.toggle('dark-mode');
                    const isDark = document.body.classList.contains('dark-mode');
                    themeToggle.textContent = isDark ? 'â˜€ï¸' : 'ðŸŒ™';
                    localStorage.setItem('theme', isDark ? 'dark' : 'light');
                    
                    // Reinitialize chart with new theme
                    this.chart.dispose();
                    this.initChart();
                    this.updateChart();
                });
            }

            initApiKey() {
                const apiKeyInput = document.getElementById('apiKeyInput');
                const apiKeyShow = document.getElementById('apiKeyShow');
                const apiKeySave = document.getElementById('apiKeySave');
                const apiKeyStatus = document.getElementById('apiKeyStatus');

                // Load saved API key from localStorage
                const savedKey = localStorage.getItem('api_key');
                if (savedKey) {
                    apiKeyInput.value = savedKey;
                    apiKeyStatus.textContent = 'API key loaded';
                    apiKeyStatus.className = 'api-key-status saved';
                } else {
                    apiKeyStatus.textContent = 'No API key set. Enter key to enable write operations.';
                    apiKeyStatus.className = 'api-key-status';
                }

                // Show/hide toggle
                apiKeyShow.addEventListener('change', (e) => {
                    apiKeyInput.type = e.target.checked ? 'text' : 'password';
                });

                // Save button
                apiKeySave.addEventListener('click', () => {
                    const key = apiKeyInput.value.trim();
                    if (key) {
                        localStorage.setItem('api_key', key);
                        apiKeyStatus.textContent = 'API key saved';
                        apiKeyStatus.className = 'api-key-status saved';
                        this.showNotification('API key saved');
                    } else {
                        localStorage.removeItem('api_key');
                        apiKeyStatus.textContent = 'API key removed';
                        apiKeyStatus.className = 'api-key-status';
                        this.showNotification('API key removed', 'error');
                    }
                });
            }

            // Get API key from localStorage for use in fetch requests
            getApiKey() {
                return localStorage.getItem('api_key') || '';
            }

            // Helper to add API key to fetch options
            getFetchOptions(method = 'GET', body = null) {
                const options = {
                    method: method,
                    headers: {}
                };
                
                const apiKey = this.getApiKey();
                if (apiKey) {
                    options.headers['X-API-Key'] = apiKey;
                }
                
                if (body) {
                    options.headers['Content-Type'] = 'application/json';
                    options.body = JSON.stringify(body);
                }
                
                return options;
            }
        }

        // Initialize dashboard when page loads
        document.addEventListener('DOMContentLoaded', () => {
            window.dashboard = new SilviaDashboard();
        });
</script>
</body>
</html>
